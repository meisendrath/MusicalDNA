//
//  ROUTING.h
//
//  Created by Burt Sloane
//  Copyright __MyCompanyName__ 2008. All rights reserved.
//

#ifndef _FP_ROUTING_H_
#define _FP_ROUTING_H_

#include "config.h"
#include "common.h"

#include <vector>
#include <string>





#define ROUTING_FROM_APPLICATION 0
#define ROUTING_FROM_NOTE_PLAYER 1
#define ROUTING_FROM_TOUCH_INPUT 2
#define ROUTING_FROM_MIDI_INPUT 3
#define ROUTING_FROM_CF_SEARCH 4
#define ROUTING_FROM_CF2_SEARCH 5
#define ROUTING_FROM_BL_SEARCH 6
#define ROUTING_FROM_BL2_SEARCH 7
#define ROUTING_FROM_MAX 8

#define ROUTING_TO_SYNTH 0
#define ROUTING_TO_SYNTH_DRUMS 1
#define ROUTING_TO_SYNTH_VIZ_VOICE 2
#define ROUTING_TO_RECORD_NOTE 3
#define ROUTING_TO_VIZUALIZER 4
#define ROUTING_TO_MIDI_OUT 5
#define ROUTING_TO_CF_SEARCH 6
#define ROUTING_TO_CF2_SEARCH 7
#define ROUTING_TO_BL_SEARCH 8
#define ROUTING_TO_BL2_SEARCH 9
#define ROUTING_TO_xxxPARTICLES 10
#define ROUTING_TO_MAX 11

#define RB_NONE -1
#define RB_ALL 0
// RB_ALL ^ (1 << 9)	// RB_ value for all but channel 9
// RB_NONE ^ (1 << 9)	// RB_ value for only channel 9


//int ROUTING_get_route(int from, int to);
void ROUTING_set_route(int from, int to, int channelmask);
//bool ROUTING_is_active(int from, int to, int ch);
void ROUTING_set_active(int from, int to, int ch, int is_active);

void ROUTING_note(int from, bool noteOn, int ch, int note, int vol, int arg1=0, float arg2=1.0f, bool track_sez_MUTE_AUDIO=false, bool track_sez_MUTE_VIZ=false);
void ROUTING_all_notes_off(int from);
void ROUTING_set_patch(int from, int ch, int inst);
int ROUTING_get_patch(int from, int ch);
void ROUTING_pitch_bend(int from, int ch, int data, bool force_viz=false);
void ROUTING_control(int from, int ch, int ctrl, int data);
void ROUTING_dump();

std::string ROUTING_serialize();
void ROUTING_deserialize(std::string s);




/*** UPDATED ROUTING GUIDE
Routing relays a "note event" from high-level note sources to low-level note sinks. High-level sources of notes include midi input, touch interface and midi sequencer. Low-level sinks for notes include synthesizer audio output, midi output and the circular visualizer. For example, a note generated by a touch on the device may be immediately sounded and visualized, as in freeplay mode, or the note may be passed to CenterFire game logic without sounding or visualizing. The table is not persistent, it is always re-constructable from the game state.
In addition to sources and sinks for notes, mid-level processors (such as CenterFire/Blaster game logic) act as a sink to recieve a note via a route in the table, potentially change it, and then act as a source and return it to the routing table for further routing. An example of this is how both blaster and centerfire alter octaves to override the touch interface, and centerfire mutes wrong notes. The caller must ensure that this mechanism does not result in a circular reference; this would ikely crash.
*** DEVICES - NOTE SOURCES
	ROUTING_FROM_APPLICATION - app-wide, plus SScreenLayoutOverlay::bail_to_main_menu() and SScreenLayoutOverlay::message()
	ROUTING_FROM_NOTE_PLAYER - NEW_CONTROLLER_execute_event() (midi sequencer)
	ROUTING_FROM_TOUCH_INPUT - LVisualizer::setNoteOn() and LVisualizer::setNoteOff()
	ROUTING_FROM_MIDI_INPUT - MDNAMIDIReadProc(), when midi events arrive from CoreMIDI
*** DEVICES - NOTE SINKS
	ROUTING_TO_SYNTH - NEW_SYNTH_rawplay() sounds the note
	ROUTING_TO_SYNTH_DRUMS - NEW_SYNTH_rawplay_drums() sounds the drum note
	ROUTING_TO_SYNTH_VIZ_VOICE - NEW_SYNTH_rawplay(), flag set to use the visualizer instrument setting
	ROUTING_TO_RECORD_NOTE - NEW_CONTROLLER_record_note() to add tracks to the active song
	ROUTING_TO_VIZUALIZER - NEW_VISUALIZER_note() to control gViz[]; also queues a high-level message "note_particle_control"
	ROUTING_TO_MIDI_OUT - MIDI_send() to post data directly to the midi output(s)
*** DEVICES - NOTE PROCESSORS
	ROUTING_TO_CF_SEARCH - sink for candidate notes in the CenterFire game; may block the note or change the octave
	ROUTING_TO_CF2_SEARCH - sink for candidate MIDI notes in the CenterFire game; may block the note or change the octave (midi notes routed separately due to midi "thru")
	ROUTING_TO_BL_SEARCH - sink for candidate notes in the Blaster game; may block the note or change the octave
	ROUTING_TO_BL2_SEARCH - sink for candidate MIDI notes in the Blaster game; may block the note or change the octave (midi notes routed separately due to midi "thru")
	ROUTING_FROM_CF_SEARCH - source for candidate notes that CenterFire logic has decided to play (routed to midi output by default)
	ROUTING_FROM_CF2_SEARCH - source for candidate notes that CenterFire logic has decided to play due to midi input (does not route to midi output)
	ROUTING_FROM_BL_SEARCH - source for candidate notes that Blaster logic has decided to play (routed to midi output by default)
	ROUTING_FROM_BL2_SEARCH - source for candidate notes that Blaster logic has decided to play due to midi input (does not route to midi output)
*** TABLES
Different routing tables are used for the different modes of the game, for example, incoming midi goes to SYNTH and VISUALIZER in freeplay mode, but in centerfire mode, incoming midi is routed to the game logic (do_centerfire_note_on()). These routing table changes are effected as the user interface transitions from state to state. A finer level of control is also possible for channel-specific routing, in order that a CenterFire "part" may specify a single channel that should be drawn in the 3D view and NOT sounded, unlike the rest of the channels in the file.
*** EXTRA DATA IN ROUTING_note()
NEW_VISUALIZER_note() needed to know which art/alpha to use in gViz[], which may be different for different instruments or different games, so was parameterized. NOTE: this could be implemented via ROUTING_control() calls to NEW_VISUALIZER_control(), and NEW_VISUALIZER maintains the data in art_index and art_alpha in gViz[].
*** TRACK MUTING
A shortcut to implementation: the functionality of track_sez_MUTE_AUDIO and track_sez_MUTE_VIZ in ROUTING_note() was implemented by making small changes to the routing table from NEW_CONTROLLER, but a previous implementation found that changing the routing table on a note-by-note basis was hard to maintain. Perhaps there are actually 4 variants of ROUTING_FROM_NOTE_PLAYER: mute off/off, mute on/off, mute on/on, mute off/on
*** LOW-LATENCY PATH FOR MIDI SEQUENCER
The midi sequencer has a latency limitation and a possible crash due to lack of performance. The latency situation has two possible fixes: 400Hz sequencer, or figuring out how to play notes a frame or two early with a delay. This second option might have MUCH lower overhead. Lack of performance (and the related failure mode) need more investigation. In both cases, the idea of the routing table is a little broken, because it is not set up to operate at interrupt speeds or to speculatively play notes ahead of time.

*** CALLS OUT
ROUTING_note() may call, depending on routing table:
	NEW_SYNTH_rawplay() and NEW_SYNTH_rawplay_drums() (muted by paramater: bool track_sez_MUTE_AUDIO)
	NEW_CONTROLLER_record_note()
	NEW_VISUALIZER_note() (muted by paramater: bool track_sez_MUTE_VIZ)
	MIDI_send()
	do_centerfire_note_on() and do_centerfire_note_off()
	do_blaster_note_on() and do_blaster_note_off()
ROUTING_all_notes_off() may call, depending on routing table:
	NEW_SYNTH_all_notes_off()
	NEW_VISUALIZER_allnotesoff()
	MIDI_send()
ROUTING_set_patch() may call, depending on routing table:
	NEW_SYNTH_set_patch()
	MIDI_send()
ROUTING_get_patch() may call, depending on routing table:
	NEW_SYNTH_get_patch()
ROUTING_control() may call, depending on routing table:
	NEW_SYNTH_control()
	MIDI_send()

*** PENDING CHANGES
remove track_sez_MUTE_AUDIO and track_sez_MUTE_VIZ from ROUTING_note() - maybe 4 variants of ROUTING_FROM_NOTE_PLAYER?
remove arg1 and arg2 from ROUTING_note() - implement NEW_VISUALIZER_control() at least for art_index and art_alpha - follow routing of FROM note source
remove awkward up-message "note_particle_control" - maybe move particle code to NEW_VISUALIZER out of LVisaulizer?
account for 400Hz operation or scheduling future notes from NOTE_PLAYER to SYNTH (what about same notes to other sinks?)
performance - how to measure? what can be measured?
possible new source - on-screen keyboard
possible new source - pitch follower
*/

#endif // !_ROUTING_H_
